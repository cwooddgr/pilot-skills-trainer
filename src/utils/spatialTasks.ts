// Spatial orientation task generation for Module D
// Assessment-safe: uses geometric shapes and abstract representations

export interface SpatialTask {
  variant: 'mental-rotation'
  stimulus: MentalRotationStimulus
  correctAnswer: number
  options: MentalRotationOption[]
  difficulty: number
}

export interface MentalRotationStimulus {
  shapePoints: Point2D[]
  referenceRotation: number
}

export interface MentalRotationOption {
  shapeIndex: number // Index into TETRIS_SHAPES array
  rotation: number
  isMirrored: boolean
}

export interface Point2D {
  x: number
  y: number
}

/**
 * Generate a mental rotation task
 */
export function generateSpatialTask(
  _variant: 'mental-rotation',
  difficulty: number
): SpatialTask {
  return generateMentalRotationTask(difficulty)
}

/**
 * Tetris tetrominoes - guaranteed asymmetric shapes
 * Each shape is made of 4 connected unit squares
 * Points define the perimeter outline (not centers)
 * No x-axis, y-axis, or rotational symmetries
 */
export const TETRIS_SHAPES: Point2D[][] = [
  // J-piece (L-shape pointing left)
  // ##
  //  #
  //  #
  // Perimeter traced clockwise from bottom-left
  // Note: L-piece is generated by mirroring J
  [
    { x: 0, y: 0 }, // bottom-left
    { x: 2, y: 0 }, // bottom-right (2 squares wide)
    { x: 2, y: 3 }, // top-right (3 squares tall)
    { x: 1, y: 3 }, // notch top
    { x: 1, y: 1 }, // notch bottom
    { x: 0, y: 1 }, // top of left square
  ],

  // F-piece (asymmetric about both axes)
  // ###
  // #
  // Perimeter traced clockwise from bottom-left
  [
    { x: 0, y: 0 }, // bottom-left
    { x: 1, y: 0 }, // right along bottom
    { x: 1, y: 1 }, // up to notch
    { x: 3, y: 1 }, // right along bottom of top row
    { x: 3, y: 2 }, // up to top-right
    { x: 0, y: 2 }, // left along top
  ],

  // Z-piece
  // ##
  //  ##
  // Perimeter traced clockwise from bottom-left
  // Note: S-piece is generated by mirroring Z
  [
    { x: 1, y: 0 }, // bottom-left
    { x: 3, y: 0 }, // bottom-right
    { x: 3, y: 1 }, // up right side
    { x: 2, y: 1 }, // left to step
    { x: 2, y: 2 }, // up to top level
    { x: 0, y: 2 }, // left along top
    { x: 0, y: 1 }, // down left side
    { x: 1, y: 1 }, // right to step
  ],
]

/**
 * Generate a mental rotation task
 * User must identify which option matches the reference shape (rotated 90°/180°/270°, not mirrored)
 */
function generateMentalRotationTask(difficulty: number): SpatialTask {
  // Select a random Tetris shape
  const shapeIndex = Math.floor(Math.random() * TETRIS_SHAPES.length)
  const baseShape = TETRIS_SHAPES[shapeIndex]

  // Reference rotation (what user sees)
  const referenceRotation = Math.floor(Math.random() * 4) * 90 // 0, 90, 180, or 270

  // Determine difficulty mode
  const useHighDifficulty = difficulty >= 0.5

  // Generate exactly 4 options
  // Task: Identify the SAME SHAPE at ANY rotation (mental rotation task)
  // Correct: Same shape rotated 90°, 180°, or 270° FROM reference (not same as reference)
  // Incorrect: Different shape OR mirrored version
  interface Option {
    shapeIndex: number
    rotation: number
    isMirrored: boolean
  }

  const optionsWithShapes: Option[] = []

  // Get other shape indices for distractors
  const otherShapeIndices = Array.from({ length: TETRIS_SHAPES.length }, (_, i) => i).filter(
    (i) => i !== shapeIndex
  )

  // Shuffle other shapes for variety
  for (let i = otherShapeIndices.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1))
    ;[otherShapeIndices[i], otherShapeIndices[j]] = [otherShapeIndices[j], otherShapeIndices[i]]
  }

  // Add correct answer (same shape rotated 90°, 180°, or 270° RELATIVE to reference)
  // This ensures correct answer is always DIFFERENT from reference
  const relativeRotation = (Math.floor(Math.random() * 3) + 1) * 90 // 90, 180, or 270
  const correctAnswerRotation = (referenceRotation + relativeRotation) % 360
  optionsWithShapes.push({
    shapeIndex: shapeIndex,
    rotation: correctAnswerRotation,
    isMirrored: false,
  })

  if (useHighDifficulty) {
    // High difficulty: All 3 distractors are mirrored (at least 2 required)
    // Distractors can be at any rotation including 0° (they're wrong answers anyway)
    optionsWithShapes.push(
      {
        shapeIndex: shapeIndex,
        rotation: Math.floor(Math.random() * 4) * 90, // Any rotation OK for distractors
        isMirrored: true, // Mirrored reference (hardest distractor)
      },
      {
        shapeIndex: otherShapeIndices[0],
        rotation: Math.floor(Math.random() * 4) * 90, // Any rotation OK
        isMirrored: true, // Different shape, mirrored
      },
      {
        shapeIndex: otherShapeIndices[1 % otherShapeIndices.length],
        rotation: Math.floor(Math.random() * 4) * 90, // Any rotation OK
        isMirrored: true, // Another different shape, mirrored
      }
    )
  } else {
    // Low difficulty: 1 mirrored distractor (reference mirrored) + 2 different shapes not mirrored
    // Distractors can be at any rotation including 0° (they're wrong answers anyway)
    optionsWithShapes.push(
      {
        shapeIndex: shapeIndex,
        rotation: Math.floor(Math.random() * 4) * 90, // Any rotation OK for distractors
        isMirrored: true, // Mirrored reference (at least 1 mirror)
      },
      {
        shapeIndex: otherShapeIndices[0],
        rotation: Math.floor(Math.random() * 4) * 90, // Any rotation OK
        isMirrored: false, // Different shape, not mirrored
      },
      {
        shapeIndex: otherShapeIndices[1 % otherShapeIndices.length],
        rotation: Math.floor(Math.random() * 4) * 90, // Any rotation OK
        isMirrored: false, // Another different shape, not mirrored
      }
    )
  }

  // Shuffle options
  const correctAnswerOption = optionsWithShapes[0]
  for (let i = optionsWithShapes.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1))
    ;[optionsWithShapes[i], optionsWithShapes[j]] = [optionsWithShapes[j], optionsWithShapes[i]]
  }

  // Find correct answer after shuffle (same shape, not mirrored)
  const correctIndex = optionsWithShapes.findIndex(
    (opt) => opt.shapeIndex === correctAnswerOption.shapeIndex && opt.isMirrored === false
  )

  // Convert to final format
  const options: MentalRotationOption[] = optionsWithShapes.map((opt) => ({
    shapeIndex: opt.shapeIndex,
    rotation: opt.rotation,
    isMirrored: opt.isMirrored,
  }))

  return {
    variant: 'mental-rotation',
    stimulus: { shapePoints: baseShape, referenceRotation },
    correctAnswer: correctIndex,
    options,
    difficulty,
  }
}

/**
 * Rotate a point around the origin
 */
export function rotatePoint(point: Point2D, angleDegrees: number): Point2D {
  const rad = (angleDegrees * Math.PI) / 180
  const cos = Math.cos(rad)
  const sin = Math.sin(rad)
  return {
    x: point.x * cos - point.y * sin,
    y: point.x * sin + point.y * cos,
  }
}

/**
 * Mirror a point across the Y axis
 */
export function mirrorPoint(point: Point2D): Point2D {
  return { x: -point.x, y: point.y }
}

/**
 * Transform shape points with rotation and optional mirror
 */
export function transformShape(
  points: Point2D[],
  rotation: number,
  mirror: boolean
): Point2D[] {
  // Center the shape first
  const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length
  const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length

  return points.map((p) => {
    // Center
    let transformed = { x: p.x - centerX, y: p.y - centerY }
    // Mirror if needed
    if (mirror) {
      transformed = mirrorPoint(transformed)
    }
    // Rotate
    transformed = rotatePoint(transformed, rotation)
    return transformed
  })
}
